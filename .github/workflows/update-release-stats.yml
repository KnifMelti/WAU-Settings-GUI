name: Update Release Download Stats

on:
  schedule:
    - cron: '0 4 * * *' # 07:00 Swedish summer time (# 06:00 Swedish winter time)
  workflow_dispatch:

jobs:
  update-stats:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Update Release Stats
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: python
        run: |
          import json
          import os
          import re
          import urllib.request
          
          token = os.environ['GITHUB_TOKEN']
          repo = os.environ['GITHUB_REPOSITORY']
          
          # Fetch releases
          req = urllib.request.Request(
              f'https://api.github.com/repos/{repo}/releases?per_page=20',
              headers={'Authorization': f'Bearer {token}'}
          )
          
          with urllib.request.urlopen(req) as response:
              releases = json.loads(response.read())
          
          # Deduplicate by ID
          seen_ids = set()
          unique_releases = []
          for release in releases:
              if release['id'] not in seen_ids:
                  seen_ids.add(release['id'])
                  unique_releases.append(release)
          
          print(f"Processing {len(unique_releases)} unique releases...")
          
          # Update each release
          for release in unique_releases:
              release_id = release['id']
              tag_name = release['tag_name']
              current_body = release.get('body', '')
              
              # Calculate total downloads
              total_downloads = sum(asset['download_count'] for asset in release.get('assets', []))
              
              # Remove existing statistics section - look for the exact header pattern
              # This will match both emoji and text variations
              if '## ' in current_body and 'Download Statistics' in current_body:
                  # Find the position of the statistics section
                  match = re.search(r'\n## [^\n]*Download Statistics', current_body)
                  if match:
                      clean_body = current_body[:match.start()].rstrip()
                  else:
                      clean_body = current_body.rstrip()
              else:
                  clean_body = current_body.rstrip()
              
              # Clean up any escaped newlines and markdown artifacts
              clean_body = clean_body.replace('\\n\\n', '\n\n')
              clean_body = clean_body.replace('\\n', '\n')
              # Remove trailing underscores and escaped sequences at the end
              clean_body = re.sub(r'(__)+\s*$', '', clean_body)
              clean_body = clean_body.rstrip()
              
              # Build new body
              new_body = f"{clean_body}\n\n## ðŸ“¥ Download Statistics\n\nEarly Swedish Mornings Totals **(ESMT): {total_downloads}**"
              
              # Update via API
              update_data = json.dumps({'body': new_body}).encode('utf-8')
              req = urllib.request.Request(
                  f'https://api.github.com/repos/{repo}/releases/{release_id}',
                  data=update_data,
                  headers={
                      'Authorization': f'Bearer {token}',
                      'Content-Type': 'application/json'
                  },
                  method='PATCH'
              )
              
              try:
                  with urllib.request.urlopen(req) as response:
                      if response.status == 200:
                          print(f"âœ“ Updated {tag_name} (Downloads: {total_downloads})")
                      else:
                          print(f"âœ— Failed to update {tag_name}: HTTP {response.status}")
              except Exception as e:
                  print(f"âœ— Error updating {tag_name}: {e}")
          
          print("Done!")
